%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% This theory formalizes the undecidability of the Post
%% Correspondence Problem
%% 
%%
%% Thiago Mendonca Ferreira Ramos, Mauricio Ayala-Rincon
%% Universidade de Brasilia
%% Last modified: 23 April 2021 by Thiago MF Ramos
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pcp  [ T : TYPE+, Alphabet : non_empty_finite_set[T]]
		: THEORY

  BEGIN
  
  IMPORTING structures@more_list_props
            ,map_identity
	    ,subtype_map
	    ,subtype_length

  
  char : TYPE = (Alphabet)
  Piece : TYPE = [list[char],list[char]]

  % From a set of Pieces represented by a non-empty list
  % of Pieces called domino, some Pieces are selected by
  % a list of indices and they are "fited".
  append_domino(domino : (cons?[Piece]),
               indices :list[below[length(domino)]]) :
	               RECURSIVE [list[(Alphabet)],list[(Alphabet)]] =
  CASES indices OF
   null : (null,null),
   cons(h,t) : LET piece = nth(domino,h),
   	           sub = append_domino(domino,t) IN
	       (append(piece`1,sub`1),append(piece`2,sub`2))
   ENDCASES
   MEASURE length(indices)

  
  % Domino-generated strings by an instance
  % dom1 of domino are also generated by
  % extensions of dom1 (dom1 o dom2) 
  % using the same indices.
   append_domino_end: LEMMA
   FORALL(dom1 : (cons?[Piece]), dom2 : list[Piece],
          indices: list[below[length(dom1)]]):
   append_domino(dom1,indices) = append_domino(append(dom1,dom2),indices)

   % Domino-generated strings by an instance
  % dom1 of domino are also generated by
  % extensions of dom2 (dom1 o dom2) 
  % adding |dom1| to the same indices.
   append_domino_begin : LEMMA
   FORALL(dom1: list[Piece], dom2: (cons?[Piece]),
          indices : list[below[length(dom2)]]):
   append_domino(dom2,indices) =
   append_domino(append(dom1,dom2),
                 map[nat,nat](LAMBDA(i : nat): length(dom1)+i)(indices))


    
    % Domino-generated strings by a domino instance,
  % domino, using indices ind1 o ind2 are also generated
  % as the concatenation of the strings generated  using
  % indices ind1 and indices ind2.
    append_domino_split_indices : LEMMA
   FORALL(domino: (cons?[Piece]), ind1,ind2: list[below[length(domino)]]):
   append_domino(domino,append(ind1,ind2)) =
   (append(append_domino(domino,ind1)`1,append_domino(domino,ind2)`1),
    append(append_domino(domino,ind1)`2,append_domino(domino,ind2)`2))


   % A valid domino does not contain a Piece that
   % the both the parts are empty.
   % This eliminates the empty solution.
   valid_domino?(domino : list[Piece]) : bool =
   cons?(domino) AND (FORALL(i : below[length(domino)]):
   cons?(nth(domino,i)`1) AND cons?(nth(domino,i)`2))

   domino_solution?(domino : (valid_domino?)) : bool =
   EXISTS(indices : (cons?[below[length(domino)]])):
   append_domino(domino,indices)`1 = append_domino(domino,indices)`2


   append_dom_without_first: SUBLEMMA
   FORALL(p1,p2: Piece, dom: list[Piece], indices: list[below[length(dom)+1]]):
   NOT member(0,indices) =>
   append_domino(cons(p1,dom),indices) =
   append_domino(cons(p2,dom),indices)

   % Note that if a domino has a solution, it has an infinite set
   % of solutions, because we can append repeating the indices of a solution
   % in a sequence. So, we fix a specific solution. 
   domino_solution_first?(domino : (valid_domino?), i : below[length(domino)])
   : bool =
   EXISTS(indices : (cons?[below[length(domino)]])):
   append_domino(domino,indices)`1 = append_domino(domino,indices)`2 AND
   car(indices) = i AND NOT member(i,cdr(indices))


   domino_solution?(domino : (valid_domino?),
                    begin_char, end_char : char) : bool =
   EXISTS(indices : (cons?[below[length(domino)]])):
   LET wu = append_domino(domino,indices)`1, 
       wd = append_domino(domino,indices)`2 IN
    wu = wd AND   
   car(wu) = begin_char AND rac(wu) = end_char
    

   compl_domino_solution?(domino : (valid_domino?)) : bool =
   NOT domino_solution?(domino)
  

    

   % IMPORTING mf_pvs0_Rices_Theorem, mf_pvs0_Rices_Theorem_Corollaries

  %  partial_r_terminating_natural_size : CONJECTURE
  %  EXISTS(pr_terminating2nat: (bijective?[computable,nat])):
  %  TRUE

  % compl_computable?(pvs0 : PVS0) : bool = partial_recursive?(pvs0) AND NOT terminating?(pvs0)

  %  compl_computable : TYPE = (compl_computable?)

   

  %  dom2PR : [list[Piece]->partial_recursive]

     

  %  pcp_undecidability: CONJECTURE
  %  FORALL(decider : computable):
  %  EXISTS(domino : (valid_domino?)):
  %  NOT (domino_solution?(domino) <=>
  %  NOT  semantic_rel(decider)(p_recursive2nat(dom2PR(domino)),false_val))
  

  END pcp
